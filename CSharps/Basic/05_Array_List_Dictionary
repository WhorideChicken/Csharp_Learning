값을 여러개를 담는 방법중 컬렉션들인 Array, List, Dicionary에 대한 내용

[Array]
- 배열은 선언과 동시에 크기를 정해야합니다.
- 한 번 선언 하면 크기는 바쑬 수 없습니다.
- 선언된 자료형만으로 값을 채워 넣을 수 있습니다.
- 배열의 시작 index는 0부터 시작입니다.
- 배열도 참조형이기 때문에 얕은 복사가 일어난다.
- 크기를 정해야하기 때문에 잘못하다간 메모리 낭비로 이어질 수 있다.

int[] score = new int[3];
score[0] = 10;

int[] score2 = socre;
score2[0] = 5;  -> score[0]의 10 값이 5로 바뀐다.


[List]
- List는 배열과 달리 가변이 가능합니다. 선언과 동시에 크기를 정할 필요가 없다.
- 내부 구조는 동적 배열이다.
- 배열과 달리, Add, Clear,insert 등의 기능을 제공하지만 그리 효율적이지 않다.
- inset를 예시로 새로운 값을 추가하면 내부적으론 배열이기 때문에 새로운 공간을 추가하고
인덱스들의 위치르 바꾼 후 빈 공간 또는 밀린 공간에 값을 삽입 하는 구조라 많은 비용이 발생
- 선언된 자료형만으로 값을 채워 넣을 수 있습니다.

 List<int> myList = new List<int>();
 myList.Add(3);

 [Dictionary]
 - Dicionary는 특정 키값을 갖고 해당 값을 찾는 자료구조로 <키,값>쌍으로 값을 저장합니다.
 - 내부적으로는 해쉬테이블을 사용합니다. 
 - Dictionary는 크기가 크기 때문에 메모리적으로 손해를 보지만 속도는 빠릅니다.
 * 결국 Key와 Value를 내부적으로 각각 배열을 만들기 때문에 공간을 많이 차지한다.
 * 메모리 공간을 손해보고 성능을 얻는 방법입니다.
 
 - 참조형 자료구조이며, 선언과 동시에 크기를 지정하기 않아도 됩니다.
 - HashTable과 차이점은 Dictionary는 자료형을 선언하기 때문에 박싱 언박싱 발생하지 않습니다.

 Dictionary<int, string> mDict = new Dictionary();